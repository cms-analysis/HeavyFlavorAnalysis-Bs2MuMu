#!/usr/bin/env perl

# Usage:       monSge [-i jobs.list] [-r]
# ------
#              check status of SGE jobs
#
# 2010/06/15   allow killing running jobs
# 2010/05/10   working again after some (previous) changes to jobs.list
# 2010/03/09   First version
#              
# ----------------------------------------------------------------------
# Send all questions, wishes and complaints to the 
#
# Author    Urs Langenegger <urs.langenegger@psi.ch>
# ----------------------------------------------------------------------

use Getopt::Std;
getopts('i:koru:');

# -- jobs list
my $jobslist = "jobs.list";
if ($opt_i) {
    $jobslist = $opt_i;
}

my $STORAGE1 = "srm://storage01.lcg.cscs.ch:8443/srm/managerv2\?SFN=";

my $goodJobs = 0; 
my $badJobs  = 0; 
my $minGood  = 9999999999; 
open(IN, $jobslist) || die "Cannot find file $joblist with grid jobs\n";
while(<IN>) {
    next if (/\#\#\#/);

    # -- parse one job: one URL/sge and one additional line with information
    my $url  = $_;   chop($url); 
    my $line = <IN>; chop($line); 

    # -- fixed screwed jobs.list input
    while ($line =~ /https/ || $line =~ /sge/) {
	$url = $line;
	$line = <IN>; chop($line); 
    }

    if ($url =~ /https/) {next;}

    $line =~ s/\# //;
    ($machine, $date, $time, $dir, $jname, $sgeNumber) = split(/ /, $line); 
    my $pwd = `pwd`; chop($pwd);
    my $mdir = $dir;
    $mdir =~ s%$pwd/%%;
    (my $logfile = $mdir) =~ s/tmp-//;  
    $logfile .= ".sge.log";

    if (-e "$mdir/$logfile") {
	$ok = parseOutput("$mdir/$logfile"); 
	($rsize, $lsize, $srmFile) = rootFileSize("$mdir/$logfile"); 
    } else {
	if (-e "$mdir/jobs.list") {
	    $ok = "waiting";
	} else {
	    print "$mdir/$logfile not found???\n";
	    next;
	}
    }

    if ($ok eq "running" || $ok eq "waiting") {
	printf("%7i %10s %30s; %s\n", $sgeNumber, $jname, $mdir, $ok);
    } else {
	printf("%7i %10s %30s; %s/root: %10i, log: %7i\n", $sgeNumber, $jname, $mdir, $ok, $rsize, $lsize);
    }

    if ($ok =~ /no problems seen/) { 
	system("/bin/touch $mdir/OK"); 
	$goodJobs++; 
	if ($rsize < $minGood) {$minGood = $rsize;}
    } elsif ($ok eq "running" || $ok eq "waiting") {
	if ($opt_k) {
	    # print "Killing job $jname $sgeNumber\n";
	    $bla = `qdel $sgeNumber`;
	    print $bla;
	}
    } else { 
	system("/bin/touch $mdir/NOK"); 
	$badJobs++; 
	if ($opt_r) {
	    print "--> removing $srmFile\n"; 
	    system("srmrm $srmFile");
	}
    }
}

print "----------------------------------------------------------------------\n";
print "Successful jobs: $goodJobs\n";
print "Failed jobs:     $badJobs\n";
if ($goodJobs > 0) {print "Minimum rootfile size of good jobs: $minGood\n";}
print "----------------------------------------------------------------------\n";


# ----------------------------------------------------------------------
sub parseOutput {
    (my $llogfile) = @_;

    my $return = "running"; 

    $foundMyEnd     = `/bin/grep -i "run: This is the end, my friend"  $llogfile`;
    if ($foundMyEnd) { $return = "no problems seen"; }

    # -- now search for possible problems in the logfile
    $foundException = `/bin/grep -i cms::exception  $llogfile`;
    if ($foundException) { $return = "cms::exception found"; }

    $foundGlibc     = `/bin/grep -i "glibc detected" $llogfile`;
    if ($foundGlibc) {$return = "core dump detected"; }
    return $return;
}


# ----------------------------------------------------------------------
sub rootFileSize {
    (my $llogfile) = @_; 

    my $result  = 0; 
    my $logsize = 0; 

    open(LIN, "$llogfile") || die "Cannot open $llogfile\n";
    my $lfn = ""; 
    # print "logfile: $llogfile\n";
    while(<LIN>) {
	if (/--> Save output to SE:/) {
	    ($bla, $lfn) = split(/SFN=/); 
	    chop($lfn); 
	    my @tmp = split(/\//, $lfn); $rfn = pop(@tmp); 
	    # print "lfn: $lfn\n";
	    # print "rfn: $rfn\n";
	    ($logn = $lfn) =~ s/root$/log/;
	}


	if ($lfn ne "" && /([0-9]*) *$lfn/) {
	    if ($1 > 0) {
		$result = $1; 
		# print "-> $result\n";
		# last; 
	    }
	}


	if ($logn ne "" && /([0-9]*) *$logn/) {
	    if ($1 > 0) {
		$logsize = $1; 
		# print "-> $logsize\n";
		# last; 
	    }
	}
    }
    close(LIN); 

    return ($result, $logsize, "$STORAGE1$lfn"); 
}
