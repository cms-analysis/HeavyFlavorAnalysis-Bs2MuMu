#!/usr/bin/env perl

#
# mkPyFiles -t file-XXXX.py [-n 5| -e 5000] -f filenames.txt -d outputDirectory -s suffix
#
# This is useful for creating a set of python files, inserting opt_n lines (or opt_e events) from opt_f, and incrementing XXXX 
#
#
# History   
# -------   
#           10/07/26  Migration to skipEvents
#           10/03/29  Bug fix: works now also for (data_replica.py compliant) file lists
#           09/12/23  Add runnumber also to output rootfilename, incremental file counting different for -r and default
#           09/12/21  Added -r option to split at run boundaries
#           09/12/08  Added printout of how many events were combined
#           09/12/04  Added opt_s to start from same skeleton into different branches (datasets)
#           09/10/26  Bug fix affecting small initial files
#	    09/09/02  Added event numbers for splitting
#           09/08/31  First shot		       
#           TODO:     split files with > opt_e events into two py files with offset
# ----------------------------------------------------------------------
# Send all questions, wishes and complaints to the 
#
# Author    Urs Langenegger <ursl@phys.ethz.ch>
# ----------------------------------------------------------------------

$hostname = `hostname`; chop($hostname); 
$directory = `pwd`;     chop($directory); 

@args = @ARGV; 
use Getopt::Std;
getopts('c:e:d:t:f:n:rs:v');

# -- this is just for convenience in here
if ($opt_c) {
    $cntEvents = 0;
    open(IN, "$opt_c") || die "cannot open $opt_c\n";
    while(<IN>){
	($bla, $cnt) = split(/\.root */);
	$cntEvents += $cnt; 
    }
    close IN; 
    die "Counted a total of $cntEvents events\n";
} 


if (!$opt_d) {
    $opt_d = "."; 
}

if (!$opt_s) {
    $opt_s = ""; 
}

if ($opt_t) {
    open(IN, "$opt_t") || die "cannot open $opt_t\n";
    @in = <IN>;
    close IN; 
    grep(s/\n//, @in); 
} else {
    die "need a template py file!\n";
}

if (!$opt_n && !$opt_e) {
    $opt_n = 1; 
}

if ($opt_f) {
    open(IN, "$opt_f") || die "cannot open $opt_f\n";
    @afiles = <IN>;
    close IN; 
    @files = grep(/\/store\//, @afiles);
} else {
    die "need dbs txt file with all the filenames\n";
}

# -- Remove stuff from dbs txt file
my $withEvents = 0; 
for ($i = 0; $i < $#afiles; $i++) {
    if ($afiles[$i] =~ /file.numevents\s*file/) {
	$withEvents = 1; 
	last;
    } 
    if ($afiles[$i] =~ /file\s*file.numevents/) {
	$withEvents = 2; 
	last;
    }
}

grep(s/\n//, @files); 

my @blockEvents;
my @blockSkipEvents;
my @block;

# -- determine total number of events
$totEvents = 0; 
$bevt = 0; 
$ib = -1; 
$oldRun = -1; 
$startNewBlock = 1; 
$blockFiles = 0; 

# -- this hash (indexed by runnumber) contains records with $RUNNUMBER, $NEVENTS, @FILELIST
#    and is filled in createRunList
my %runList;
&createRunList();

# -- produce python files per run
if ($opt_r) {
    &createPyFilesPerRun();
} else {
    &createPyFilesPerBlock();
}

die "\n";


if ($opt_e) {
    if ($withEvents <= 0) {
	die "need event numbers in dbs txt file when using -e $opt_e\n";
    }

    for ($i = 0; $i <= $#files; $i++) {
	# -- skip lines that do not contain filenames
	if (!($files[$i] =~ /.*\.root/)) {next;}
	# -- change format for parsing
	$files[$i] =~ s/\t/:/g;
	$files[$i] =~ s/\s{1,99}/:/g;
	
	if ($withEvents == 1) {
	    ($num, $filename) = split(/:/, $files[$i]); 
	} elsif ($withEvents == 2) {
	    ($filename, $num) = split(/:/, $files[$i]); 
	}
	if ($num == 0) {next;}
	
	# -- get runnumber
	@bblocks =  split(/\//, $filename); 
	$run = $bblocks[$#bblocks-2]*1000 + $bblocks[$#bblocks-1];
	#print "-> $run\n";
	
	$totEvents += $num; 
	$bevt += $num; 
	
	if ($bevt > $opt_e) {
	    $startNewBlock = 1; 
	}
	
	if ($opt_r && $run != $oldRun) {
	    $startNewBlock = 1; 
	    $oldRun = $run; 
	    $blockFiles = 0;
	}
	
	if ($opt_v) {print "$num..$bevt..$ib..$run..$filename\n";}
	
	# do not insert empty files into filelist block
	if ($num < 1) {next;} 
	
	if ($startNewBlock > 0) {
	    $ib++; 
	    $block[$ib] = " \"$filename\"";
	    if ($opt_r) {
		$blockName[$ib]   = sprintf("-%d-%04d", $run, $blockFiles);
		$blockFiles++;
	    } else {
		$blockName[$ib] = "";
	    }		    
	    $startNewBlock = 0; 
	    $bevt = $num; 
	    $blockEvents[$ib] = $bevt; 
	} else {
	    $blockEvents[$ib] = $bevt; 
	    $block[$ib] = $block[$ib] . ",\n " . "\"$filename\"";
	}
    }
}


if ($opt_v) {
    for ($i = 0; $i <= $#block; $i++) {
	print "==> $i:\n$block[$i]\n\n";
    }
}

# -- calculate the number of files to be produced
if ($opt_e) {
    $nfiles = $#block; 
} elsif ($opt_n) {
    $nfiles = int($#files/$opt_n); 
}

my $bLine = 0; 
for ($i = 0; $i <= $nfiles; $i++) {
    if ($opt_r) {
	# do nothing
    } else {
	$blockName[$i] = sprintf("-%04d", $i);
    }

    ($fileName = $opt_t) =~ s/XXXX/$opt_s$blockName[$i]/g;
    
    $tmp = $fileName; @tmp = split(/\//, $fileName); $fileName = pop(@tmp); # strip path
    $fileName = $opt_d . "/" . $fileName; 
    printf("producing file: %s\n", $fileName); 
    open(OUT, ">$fileName") || die "Cannot open $fileName for output\n";
    print OUT "# ######################################################################\n";
    print OUT "# $hostname\n";
    print OUT "# $directory\n";
    print OUT "# mkPyFiles @args\n";
    print OUT "# $fileName with $blockEvents[$i] events\n";
    print OUT "# ######################################################################\n";

    
    for ($l = 0; $l <= $#in; $l++) {
	# -- increment numbering
	if ($in[$l] =~ /XXXX/) {
	    ($tmp = $in[$l]) =~ s/XXXX/$opt_s$blockName[$i]/g; 
	    print OUT $tmp, "\n";
	}
	# -- substitute files
	elsif ($in[$l] =~ /REPLACEFILES/) {
	    if ($opt_n) {
		$startline = $i*$opt_n; 
		$endline = ($i+1)*$opt_n; 
		for ($j = $startline; $j < $endline; $j++) {
		    if (length($files[$j+1]) > 1) {
			if ($j < $endline-1) {
			    print OUT "   \"$files[$j]\", \n"; 
			} else {
			    print OUT "   \"$files[$j]\" \n"; 
			}
		    } else {
			print OUT "   \"$files[$j]\"\n"; 
			last;
		    }	    
		}
	    } elsif ($opt_e) {
		print OUT @block[$bLine];
		print OUT "\n";
		$bLine++;
	    }
	} else {
	    print OUT $in[$l], "\n"; 
	}
    }

    close(OUT); 
}



# ----------------------------------------------------------------------
sub createRunList() {

    $runEventNumber = 0; 
    $oldrun = 0; 
    $num = 0; 

    for ($i = 0; $i <= $#files; $i++) {
	# -- skip lines that do not contain filenames
	if (!($files[$i] =~ /.*\.root/)) {next;}
	# -- change format for parsing
	$files[$i] =~ s/\t/:/g;
	$files[$i] =~ s/\s{1,99}/:/g;

	if ($withEvents == 1) {
	    ($num, $filename) = split(/:/, $files[$i]); 
	} elsif ($withEvents == 2) {
	    ($filename, $num) = split(/:/, $files[$i]); 
	}
	if ($num == 0) {next;}

        # -- get runnumber
	@bblocks =  split(/\//, $filename); 
	$run = $bblocks[$#bblocks-2]*1000 + $bblocks[$#bblocks-1];

	push(@fileList, $filename); 
	$runEventNumber += $num; 
	if ($run != $oldrun) {
	    if ($oldrun == 0) {
		$oldrun = $run;
		next; 
	    }

	    pop(@fileList);
	    $runEventNumber -= $num; 

	    createRunRecord($oldrun, $runEventNumber, @fileList); 

	    # -- set up new run 
	    $oldrun = $run;
	    @fileList = (); 
	    push(@fileList, $filename); 
	    $runEventNumber = $num; 

	}
    }
    
    # -- push out final line/run as well
    createRunRecord($oldrun, $runEventNumber, @fileList); 
}



# ----------------------------------------------------------------------
sub createRunRecord() {
    local($run, $nevts, @files) = @_;

    print "finish old run: $oldrun with $runEventNumber events\n";
    for ($j = 0; $j <= $#files; $j++) {
	print "$files[$j] \n";
    }
    
    $runInfo = {
	RUNNUMBER => $run,
	NEVENTS  => $nevts,
	FILELIST => [@files],
    };
    
    $runList{$run} =  $runInfo; 
}


# ----------------------------------------------------------------------
sub createPyFilesPerRun() {
    
    foreach $run (sort keys %runList) {

	$njobs = $runList{$run}->{NEVENTS}/$opt_e;
	for ($iJob = 0; $iJob < $njobs; $iJob++) {

	    if ($opt_s) {
		$blockName = sprintf("-%s", $opt_s);
	    }

	    if ($opt_r) {
		$blockName .= sprintf("-%07i", $run);
	    }


	    $blockName .= sprintf("-%04i", $iJob);
	    $skipevents = $iJob*$opt_e; 
	    ($fileName = $opt_t) =~ s/XXXX/$blockName/g;
	    $fileName  =~ s/--/-/g; # -- remove spurious double hyphens ...
	    $tmp = $fileName; @tmp = split(/\//, $fileName); $fileName = pop(@tmp); # strip path
	    $fileName = $opt_d . "/" . $fileName; 

	    printf("producing file: %s\n", $fileName); 
	    open(OUT, ">$fileName") || die "Cannot open $fileName for output\n";
	    print OUT "# ######################################################################\n";
            print OUT "# $hostname\n";
	    print OUT "# $directory\n";
	    print OUT "# file list contains $runList{$run}->{NEVENTS} events\n";
	    print OUT "# mkPyFiles @args\n";
	    print OUT "# $fileName with $opt_e events, skipEvents = $skipevents\n";
	    print OUT "# ######################################################################\n";

		
            for ($l = 0; $l <= $#in; $l++) {
		# -- increment numbering
		if ($in[$l] =~ /XXXX/) {
		    ($tmp = $in[$l]) =~ s/XXXX/$blockName/g; 
		    $tmp  =~ s/--/-/g; # -- remove spurious double hyphens ...
		    print OUT $tmp, "\n";
		}
		# -- substitute files and skipevents and nevents
		elsif ($in[$l] =~ /POOLSOURCE/) {
		    print OUT "process.source = cms.Source(\n";
		    print OUT " \"PoolSource\",\n";
		    print OUT "  fileNames = cms.untracked.vstring(\n";
		    @bla = @{$runList{$run}->{FILELIST}}; 
		    for ($ij = 0; $ij <= $#bla; $ij++) {
			if ($ij < $#bla) {
			    print OUT "         \"$bla[$ij]\",\n";
			} else {
			    print OUT "         \"$bla[$ij]\"\n";
			}
		    }
		    
		    if ($skipevents > 0) {
			print OUT " ),\n";
			print OUT " skipEvents = cms.untracked.uint32(";
			print OUT $skipevents;
			print OUT ")\n";
		    } else {
			print OUT " )\n";
		    }
		    
		    print OUT ")\n";
		    if ($runList{$run}->{NEVENTS} < $opt_e) {
			print OUT "process.maxEvents = cms.untracked.PSet( input = cms.untracked.int32(-1) )\n";
		    } else {
			print OUT "process.maxEvents = cms.untracked.PSet( input = cms.untracked.int32($opt_e) )\n";
		    }
		}
		
		
		# -- substitute files
		elsif ($in[$l] =~ /REPLACEFILES/) {
		    if ($opt_n) {
			$startline = $i*$opt_n; 
			$endline = ($i+1)*$opt_n; 
			for ($j = $startline; $j < $endline; $j++) {
			    if (length($files[$j+1]) > 1) {
				if ($j < $endline-1) {
				    print OUT "   \"$files[$j]\", \n"; 
				} else {
				    print OUT "   \"$files[$j]\" \n"; 
				}
			    } else {
				print OUT "   \"$files[$j]\"\n"; 
				last;
			    }	    
			}
		    } elsif ($opt_e) {
			print OUT @block[$bLine];
			print OUT "\n";
			$bLine++;
		    }
		} else {
		    print OUT $in[$l], "\n"; 
		}
	    }
	    
	    close(OUT); 
	    
	}
	
	
    }
    


}


# ----------------------------------------------------------------------
sub createPyFilesPerBlock() {
    
    foreach $run (sort keys %runList) {

	$njobs = $runList{$run}->{NEVENTS}/$opt_e;
	for ($iJob = 0; $iJob < $njobs; $iJob++) {

	    if ($opt_s) {
		$blockName = sprintf("-%s", $opt_s);
	    }

	    if ($opt_r) {
		$blockName .= sprintf("-%07i", $run);
	    }


	    $blockName .= sprintf("-%04i", $iJob);
	    $skipevents = $iJob*$opt_e; 
	    ($fileName = $opt_t) =~ s/XXXX/$blockName/g;
	    $fileName  =~ s/--/-/g; # -- remove spurious double hyphens ...
	    $tmp = $fileName; @tmp = split(/\//, $fileName); $fileName = pop(@tmp); # strip path
	    $fileName = $opt_d . "/" . $fileName; 

	    printf("producing file: %s\n", $fileName); 
	    open(OUT, ">$fileName") || die "Cannot open $fileName for output\n";
	    print OUT "# ######################################################################\n";
            print OUT "# $hostname\n";
	    print OUT "# $directory\n";
	    print OUT "# file list contains $runList{$run}->{NEVENTS} events\n";
	    print OUT "# mkPyFiles @args\n";
	    print OUT "# $fileName with $opt_e events, skipEvents = $skipevents\n";
	    print OUT "# ######################################################################\n";

		
            for ($l = 0; $l <= $#in; $l++) {
		# -- increment numbering
		if ($in[$l] =~ /XXXX/) {
		    ($tmp = $in[$l]) =~ s/XXXX/$blockName/g; 
		    $tmp  =~ s/--/-/g; # -- remove spurious double hyphens ...
		    print OUT $tmp, "\n";
		}
		# -- substitute files and skipevents and nevents
		elsif ($in[$l] =~ /POOLSOURCE/) {
		    print OUT "process.source = cms.Source(\n";
		    print OUT " \"PoolSource\",\n";
		    print OUT "  fileNames = cms.untracked.vstring(\n";
		    @bla = @{$runList{$run}->{FILELIST}}; 
		    for ($ij = 0; $ij <= $#bla; $ij++) {
			if ($ij < $#bla) {
			    print OUT "         \"$bla[$ij]\",\n";
			} else {
			    print OUT "         \"$bla[$ij]\"\n";
			}
		    }
		    
		    if ($skipevents > 0) {
			print OUT " ),\n";
			print OUT " skipEvents = cms.untracked.uint32(";
			print OUT $skipevents;
			print OUT ")\n";
		    } else {
			print OUT " )\n";
		    }
		    
		    print OUT ")\n";
		    if ($runList{$run}->{NEVENTS} < $opt_e) {
			print OUT "process.maxEvents = cms.untracked.PSet( input = cms.untracked.int32(-1) )\n";
		    } else {
			print OUT "process.maxEvents = cms.untracked.PSet( input = cms.untracked.int32($opt_e) )\n";
		    }
		}
		
		
		# -- substitute files
		elsif ($in[$l] =~ /REPLACEFILES/) {
		    if ($opt_n) {
			$startline = $i*$opt_n; 
			$endline = ($i+1)*$opt_n; 
			for ($j = $startline; $j < $endline; $j++) {
			    if (length($files[$j+1]) > 1) {
				if ($j < $endline-1) {
				    print OUT "   \"$files[$j]\", \n"; 
				} else {
				    print OUT "   \"$files[$j]\" \n"; 
				}
			    } else {
				print OUT "   \"$files[$j]\"\n"; 
				last;
			    }	    
			}
		    } elsif ($opt_e) {
			print OUT @block[$bLine];
			print OUT "\n";
			$bLine++;
		    }
		} else {
		    print OUT $in[$l], "\n"; 
		}
	    }
	    
	    close(OUT); 
	    
	}
	
	
    }
    


}
