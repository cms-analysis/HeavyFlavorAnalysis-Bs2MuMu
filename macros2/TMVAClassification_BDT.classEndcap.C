// Class: ReadBDT2
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT2::BDT2
TMVA Release   : 4.1.2         [262402]
ROOT Release   : 5.27/06       [334598]
Creator        : tinti_g
Date           : Wed Jan  4 23:01:23 2012
Host           : Linux lxbuild151.cern.ch 2.6.18-194.11.3.el5.cve20103081 #1 SMP Thu Sep 16 15:17:10 CEST 2010 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /shome/tinti_g/TMVA/test
Training events: 12655
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
BoostType: "AdaBoost" [Boosting type for the trees in the forest]
AdaBoostBeta: "5.000000e-01" [Parameter for AdaBoost algorithm]
SeparationType: "giniindex" [Separation criterion for node splitting]
nEventsMin: "300" [Minimum number of events required in a leaf node (default: Classification: max(40, N_train/(Nvar^2)/10), Regression: 10)]
nCuts: "30" [Number of steps during node cut optimisation]
PruneMethod: "nopruning" [Method used for pruning (removal) of statistically insignificant branches]
MaxDepth: "3" [Max depth of the decision tree allowed]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
RenormByClass: "False" [Individually re-normalize each event class to the original size after boosting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2t (Linear,Quadratic or Exponential)]
UseBaggedGrad: "False" [Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost)]
GradBaggingFraction: "6.000000e-01" [Defines the fraction of events to be used in each iteration when UseBaggedGrad=kTRUE. (Only valid for GradBoost)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
UseRandomisedTrees: "False" [Choose at each node splitting a random set of variables]
UseNvars: "3" [Number of variables used if randomised tree option is chosen]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split]
UseNTrainEvents: "12655" [Number of randomly picked training events used in randomised (and bagged) trees]
UseWeightedTrees: "True" [Use weighted trees or simple average in classification from the forest]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
PruneStrength: "0.000000e+00" [Pruning strength]
PruneBeforeBoost: "False" [Flag to prune the tree before applying boosting algorithm]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
NNodesMax: "100000" [Max number of nodes in tree]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT2 training (particular the boosting) : Ignore;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!); Randomly pair events with negative and positive weights in leaf node and do not boost them (experimental!) ]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 10
alpha                         alpha                         alpha                         pointing angle                                                  'F'    [0.000320086051943,0.199997499585]
fls3d                         fls3d                         fls3d                         3D flight length significance                                   'F'    [5.00079488754,235.267944336]
iso                           iso                           iso                           isolation                                                       'F'    [0.0992664992809,1]
m1pt                          m1pt                          m1pt                          m1pt (GeV)                                                      'F'    [4.50234794617,52.8474884033]
m2pt                          m2pt                          m2pt                          m2pt (GeV)                                                      'F'    [4.00032567978,21.5767230988]
m1eta                         m1eta                         m1eta                         m1 #eta                                                         'F'    [-2.39987421036,2.39998412132]
m2eta                         m2eta                         m2eta                         m2 #eta                                                         'F'    [-2.39862179756,2.39984822273]
docatrk                       docatrk                       docatrk                       doca (cm)                                                       'F'    [1.44957757584e-05,10.9611825943]
pvlips                        pvlips                        pvlips                        PV IP significance                                              'F'    [-2.49668335915,2.63318514824]
closetrk                      closetrk                      closetrk                      N^{#DeltaR}_{trk}                                               'F'    [0,20]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN2 new BDT2Node
   
#ifndef BDT2Node__def
#define BDT2Node__def
   
class BDT2Node {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDT2Node ( BDT2Node* left,BDT2Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDT2Node();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDT2Node* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDT2Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDT2Node*   fLeft;     // pointer to the left daughter node
   BDT2Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDT2Node::~BDT2Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDT2Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDT2Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT2 : public IClassifierReader {

 public:

   // constructor
   ReadBDT2( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT2" ),
        fNvars( 10 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "alpha", "fls3d", "iso", "m1pt", "m2pt", "m1eta", "m2eta", "docatrk", "pvlips", "closetrk" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0.000320086051942781;
      fVmax[0] = 0.199997499585152;
      fVmin[1] = 5.00079488754272;
      fVmax[1] = 235.267944335938;
      fVmin[2] = 0.0992664992809296;
      fVmax[2] = 1;
      fVmin[3] = 4.50234794616699;
      fVmax[3] = 52.8474884033203;
      fVmin[4] = 4.00032567977905;
      fVmax[4] = 21.5767230987549;
      fVmin[5] = -2.39987421035767;
      fVmax[5] = 2.39998412132263;
      fVmin[6] = -2.39862179756165;
      fVmax[6] = 2.39984822273254;
      fVmin[7] = 1.44957757584052e-05;
      fVmax[7] = 10.9611825942993;
      fVmin[8] = -2.49668335914612;
      fVmax[8] = 2.63318514823914;
      fVmin[9] = 0;
      fVmax[9] = 20;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT2() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[10];
   double fVmax[10];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[10];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDT2Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT2::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDT2Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDT2Node*)current->GetRight();
         else current=(BDT2Node*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT2::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(3.72077119036814);
  fForest.push_back( 
NN2(
0, 
0, 
-1, 0.0132025, 1, -1, 0.000586036,-99)    );
  // itree = 1
  fBoostWeights.push_back(2.02015);
  fForest.push_back( 
NN2(
NN2(
NN2(
0, 
0, 
-1, 34.7178, 0, 1, 0.896748,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.278031,-99) , 
9, 0.516129, 1, 0, 0.539469,-99) , 
NN2(
0, 
0, 
-1, 0.0312814, 1, -1, 0.0136778,-99) , 
0, 0.0132025, 1, 0, 0.0236428,-99)    );
  // itree = 2
  fBoostWeights.push_back(1.30708);
  fForest.push_back( 
NN2(
NN2(
NN2(
0, 
0, 
-1, 12.4296, 0, 1, 0.762543,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.169131,-99) , 
2, 0.74936, 0, 0, 0.590788,-99) , 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.510353,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.0842288,-99) , 
0, 0.0649464, 1, 0, 0.17184,-99) , 
NN2(
0, 
0, 
-1, 0.0595616, 1, -1, 0.0189463,-99) , 
2, 0.912832, 0, 0, 0.0463709,-99) , 
0, 0.0325261, 1, 0, 0.117955,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.912084);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.725316,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.448507,-99) , 
0, 0.0235452, 1, 0, 0.633024,-99) , 
NN2(
0, 
0, 
-1, 7.39698, 0, -1, 0.264841,-99) , 
1, 12.4292, 0, 0, 0.412602,-99) , 
NN2(
0, 
0, 
-1, 0.85472, 0, -1, 0.088599,-99) , 
0, 0.0454085, 1, 0, 0.16876,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.593542);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.597869,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.302558,-99) , 
5, 1.93198, 1, 0, 0.549207,-99) , 
NN2(
0, 
0, 
-1, 0.904413, 0, -1, 0.245256,-99) , 
0, 0.103379, 1, 0, 0.456781,-99) , 
NN2(
0, 
0, 
-1, 0.0454148, 1, -1, 0.131318,-99) , 
2, 0.825664, 0, 0, 0.288849,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.484379);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.602123,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.316985,-99) , 
3, 12.301, 1, 0, 0.55241,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.296789,-99) , 
6, -1.77909, 0, 0, 0.502805,-99) , 
NN2(
0, 
0, 
-1, 0.796609, 0, -1, 0.22187,-99) , 
0, 0.0518497, 1, 0, 0.32504,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.451062);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.600677,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.37809,-99) , 
5, 1.45572, 1, 0, 0.520481,-99) , 
NN2(
0, 
0, 
-1, -0.569046, 0, -1, 0.251137,-99) , 
5, -1.77886, 0, 0, 0.469876,-99) , 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.603384,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.288595,-99) , 
1, 7.56682, 0, 0, 0.518346,-99) , 
NN2(
0, 
0, 
-1, 0.130217, 1, -1, 0.0546541,-99) , 
0, 0.0457585, 1, 0, 0.190979,-99) , 
2, 0.767553, 0, 0, 0.372103,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.345317);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.59223,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.405891,-99) , 
2, 0.943764, 0, 0, 0.475795,-99) , 
NN2(
0, 
0, 
-1, 0.0391159, 1, -1, 0.264314,-99) , 
6, -1.77929, 0, 0, 0.439172,-99) , 
NN2(
0, 
0, 
-1, 0.0330716, 1, -1, 0.128551,-99) , 
2, 0.651329, 0, 0, 0.380256,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.257851);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.535868,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.313864,-99) , 
5, -1.9336, 0, 0, 0.505696,-99) , 
NN2(
0, 
0, 
-1, 0.831292, 0, -1, 0.276859,-99) , 
0, 0.135585, 1, 0, 0.470431,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.513094,-99) , 
NN2(
0, 
0, 
-1, 0.108293, 1, -1, 0.0741903,-99) , 
0, 0.0330716, 1, 0, 0.172428,-99) , 
2, 0.651329, 0, 0, 0.418115,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.209878);
  fForest.push_back( 
NN2(
0, 
0, 
-1, 0.651329, 0, -1, 0.396575,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.22501);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.543835,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.317756,-99) , 
8, -0.852778, 0, 0, 0.512997,-99) , 
NN2(
0, 
0, 
-1, 0.999816, 1, -1, 0.260254,-99) , 
8, 1.14398, 1, 0, 0.491724,-99) , 
NN2(
0, 
0, 
-1, 0.0458835, 1, -1, 0.213671,-99) , 
2, 0.651329, 0, 0, 0.447722,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.146331);
  fForest.push_back( 
NN2(
0, 
0, 
-1, 0.564161, 0, -1, 0.427352,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.164663);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.530918,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.352214,-99) , 
6, -1.81946, 0, 0, 0.502567,-99) , 
NN2(
0, 
0, 
-1, 0.271931, 1, -1, 0.232462,-99) , 
6, 2.09027, 1, 0, 0.487171,-99) , 
NN2(
0, 
0, 
-1, 0.0458835, 1, -1, 0.19535,-99) , 
2, 0.564161, 0, 0, 0.463482,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.241314);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.553284,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.419951,-99) , 
5, -1.46938, 0, 0, 0.504216,-99) , 
NN2(
0, 
0, 
-1, 0.264459, 1, -1, 0.349782,-99) , 
6, 1.78072, 1, 0, 0.479265,-99) , 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.66071,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.348926,-99) , 
3, 8.39995, 1, 0, 0.562908,-99) , 
NN2(
0, 
0, 
-1, 0.110431, 1, -1, 0.157906,-99) , 
0, 0.045913, 1, 0, 0.312108,-99) , 
2, 0.709441, 0, 0, 0.44392,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.140971);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.5036,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.25478,-99) , 
8, 1.05029, 1, 0, 0.488575,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.554809,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.156533,-99) , 
2, 0.898806, 0, 0, 0.343398,-99) , 
0, 0.116262, 1, 0, 0.457918,-99) , 
NN2(
0, 
0, 
-1, 10.4812, 0, -1, 0.108696,-99) , 
2, 0.476993, 0, 0, 0.445604,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.168384);
  fForest.push_back( 
NN2(
NN2(
NN2(
0, 
0, 
-1, -1.5035, 0, -1, 0.462587,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.561899,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.268818,-99) , 
7, 0.0244772, 0, 0, 0.33651,-99) , 
5, 1.62581, 1, 0, 0.433427,-99) , 
NN2(
0, 
0, 
-1, 10.4812, 0, -1, 0.123125,-99) , 
2, 0.476993, 0, 0, 0.422985,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.136381);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.51994,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.276903,-99) , 
9, 10.3226, 1, 0, 0.508069,-99) , 
NN2(
0, 
0, 
-1, 0.81509, 0, -1, 0.23962,-99) , 
8, -1.50381, 0, 0, 0.494725,-99) , 
NN2(
0, 
0, 
-1, 0.738507, 1, -1, 0.342246,-99) , 
5, 1.62581, 1, 0, 0.460087,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.108278);
  fForest.push_back( 
NN2(
0, 
0, 
-1, 0.476993, 0, -1, 0.446071,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0896674);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.510516,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.327616,-99) , 
8, -1.20474, 0, 0, 0.497412,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.502881,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.134797,-99) , 
6, 0.999816, 1, 0, 0.314711,-99) , 
8, 1.14398, 1, 0, 0.483248,-99) , 
NN2(
0, 
0, 
-1, 10.4812, 0, -1, 0.147986,-99) , 
2, 0.476993, 0, 0, 0.472957,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0907077);
  fForest.push_back( 
NN2(
NN2(
NN2(
0, 
0, 
-1, 1.372, 1, -1, 0.487979,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.505854,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.0881906,-99) , 
2, 0.814477, 0, 0, 0.376193,-99) , 
0, 0.116262, 1, 0, 0.465475,-99) , 
NN2(
0, 
0, 
-1, 10.4812, 0, -1, 0.159652,-99) , 
2, 0.476993, 0, 0, 0.456347,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.140389);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.523863,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.364391,-99) , 
5, 2.09035, 1, 0, 0.512182,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.188219,-99) , 
8, 1.37143, 1, 0, 0.504016,-99) , 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.537303,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.211299,-99) , 
6, -1.61741, 0, 0, 0.487382,-99) , 
NN2(
0, 
0, 
-1, 0.661554, 0, -1, 0.109078,-99) , 
2, 0.825664, 0, 0, 0.349944,-99) , 
0, 0.116262, 1, 0, 0.472793,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.127548);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.513409,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.441918,-99) , 
4, 5.13429, 1, 0, 0.482195,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.210613,-99) , 
8, 1.37143, 1, 0, 0.475613,-99) , 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.503616,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.154838,-99) , 
5, 1.77877, 1, 0, 0.462677,-99) , 
NN2(
0, 
0, 
-1, 0.661554, 0, -1, 0.123488,-99) , 
2, 0.825664, 0, 0, 0.34301,-99) , 
0, 0.116262, 1, 0, 0.449199,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.143422);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.524243,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.450549,-99) , 
9, 1.29032, 1, 0, 0.481381,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.319629,-99) , 
6, 2.09027, 1, 0, 0.472307,-99) , 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.506259,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.265453,-99) , 
1, 8.13377, 1, 0, 0.437963,-99) , 
NN2(
0, 
0, 
-1, 0.661554, 0, -1, 0.137969,-99) , 
2, 0.825664, 0, 0, 0.335089,-99) , 
0, 0.116262, 1, 0, 0.445317,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.098395);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.500231,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.390881,-99) , 
1, 19.8567, 1, 0, 0.48554,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.233184,-99) , 
8, 1.37143, 1, 0, 0.479694,-99) , 
NN2(
0, 
0, 
-1, 0.680385, 0, -1, 0.333103,-99) , 
0, 0.116262, 1, 0, 0.451276,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.11639);
  fForest.push_back( 
NN2(
0, 
0, 
-1, 0.476993, 0, -1, 0.442066,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.082626);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.508378,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.380105,-99) , 
5, -2.08977, 0, 0, 0.49795,-99) , 
NN2(
0, 
0, 
-1, 0.76388, 0, -1, 0.396392,-99) , 
0, 0.116262, 1, 0, 0.478843,-99) , 
NN2(
0, 
0, 
-1, 10.4812, 0, -1, 0.191392,-99) , 
2, 0.476993, 0, 0, 0.470935,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0771528);
  fForest.push_back( 
NN2(
0, 
0, 
-1, 0.476993, 0, -1, 0.4615,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.064981);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.508193,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.411406,-99) , 
6, -1.77946, 0, 0, 0.49259,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.197988,-99) , 
8, 1.80585, 1, 0, 0.487854,-99) , 
NN2(
0, 
0, 
-1, 10.4812, 0, -1, 0.217344,-99) , 
2, 0.476993, 0, 0, 0.480721,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.13275);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.563747,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.45633,-99) , 
8, 0.151172, 0, 0, 0.497199,-99) , 
NN2(
0, 
0, 
-1, 0.738507, 1, -1, 0.407093,-99) , 
5, 1.62581, 1, 0, 0.47725,-99) , 
NN2(
0, 
0, 
-1, 10.4812, 0, -1, 0.2286,-99) , 
2, 0.476993, 0, 0, 0.470801,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0681588);
  fForest.push_back( 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.661828,-99) , 
NN2(
0, 
0, 
-1, 0.575645, 0, -1, 0.488613,-99) , 
0, 0.00676129, 1, 0, 0.496425,-99) , 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.577619,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.108476,-99) , 
2, 0.767553, 0, 0, 0.466426,-99) , 
NN2(
0, 
0, 
-1, 1.34017, 1, -1, 0.12178,-99) , 
6, 1.31331, 1, 0, 0.331835,-99) , 
8, 1.14387, 1, 0, 0.484681,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.110736);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.544197,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.485349,-99) , 
5, -1.31444, 0, 0, 0.520936,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.578785,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.146237,-99) , 
0, 0.0458835, 1, 0, 0.384705,-99) , 
2, 0.575645, 0, 0, 0.511937,-99) , 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.535515,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.188515,-99) , 
2, 0.825664, 0, 0, 0.415249,-99) , 
NN2(
0, 
0, 
-1, 1.92044, 1, -1, 0.0259636,-99) , 
6, 1.62176, 1, 0, 0.330246,-99) , 
8, 1.14387, 1, 0, 0.499155,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.113857);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.536474,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.451705,-99) , 
6, 1.51071, 1, 0, 0.514638,-99) , 
NN2(
0, 
0, 
-1, 0.0916083, 1, -1, 0.354667,-99) , 
6, 2.09027, 1, 0, 0.506371,-99) , 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.541763,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.127026,-99) , 
2, 0.767553, 0, 0, 0.447492,-99) , 
NN2(
0, 
0, 
-1, 1.34017, 1, -1, 0.130161,-99) , 
6, 1.31331, 1, 0, 0.325679,-99) , 
8, 1.14387, 1, 0, 0.493873,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.100076);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.537323,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.467634,-99) , 
8, -0.0226845, 1, 0, 0.502051,-99) , 
NN2(
0, 
0, 
-1, -1.46664, 0, -1, 0.326778,-99) , 
8, -1.43984, 0, 0, 0.494741,-99) , 
NN2(
0, 
0, 
-1, 1.62176, 1, -1, 0.322723,-99) , 
8, 1.14387, 1, 0, 0.483057,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0748807);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.514559,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.407686,-99) , 
8, -0.852498, 0, 0, 0.501584,-99) , 
NN2(
0, 
0, 
-1, 1.6158, 1, -1, 0.357152,-99) , 
8, 1.14398, 1, 0, 0.491995,-99) , 
NN2(
0, 
0, 
-1, 10.4812, 0, -1, 0.243717,-99) , 
2, 0.476993, 0, 0, 0.48593,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.14214);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.652789,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.47654,-99) , 
2, 0.74936, 1, 0, 0.520572,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.516563,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.27274,-99) , 
2, 0.801968, 0, 0, 0.453392,-99) , 
0, 0.0454085, 1, 0, 0.483043,-99) , 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.511119,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.327007,-99) , 
0, 0.0767059, 0, 0, 0.404818,-99) , 
NN2(
0, 
0, 
-1, 0.411551, 0, -1, 0.0907332,-99) , 
0, 0.117267, 1, 0, 0.327849,-99) , 
9, 9.03226, 1, 0, 0.474624,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.142926);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.841096,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.490203,-99) , 
4, 5.70241, 0, 0, 0.635962,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.546884,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.438978,-99) , 
6, 1.47043, 1, 0, 0.508023,-99) , 
0, 0.0104984, 1, 0, 0.529877,-99) , 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.50295,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.276255,-99) , 
6, -1.77999, 0, 0, 0.474675,-99) , 
NN2(
0, 
0, 
-1, 3.22581, 0, -1, 0.277641,-99) , 
2, 0.767553, 0, 0, 0.431009,-99) , 
0, 0.0454085, 1, 0, 0.473432,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.152151);
  fForest.push_back( 
NN2(
NN2(
NN2(
0, 
0, 
-1, 5.70241, 0, 1, 0.645049,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.580056,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.472806,-99) , 
6, 1.62518, 0, 0, 0.49803,-99) , 
0, 0.0104984, 1, 0, 0.522858,-99) , 
NN2(
NN2(
0, 
0, 
-1, 1.77989, 1, -1, 0.461903,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.533354,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.180391,-99) , 
9, 0.612903, 1, 0, 0.300583,-99) , 
1, 9.09108, 1, 0, 0.417213,-99) , 
0, 0.0454085, 1, 0, 0.462561,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.174174);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.683357,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.479628,-99) , 
0, 0.0282252, 1, 0, 0.606708,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.547191,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.409059,-99) , 
0, 0.0134065, 0, 0, 0.508654,-99) , 
2, 0.74936, 1, 0, 0.53345,-99) , 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.533309,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.291875,-99) , 
5, 1.77989, 1, 0, 0.499867,-99) , 
NN2(
0, 
0, 
-1, 0.612903, 1, -1, 0.306153,-99) , 
1, 9.09108, 1, 0, 0.447302,-99) , 
0, 0.0454085, 1, 0, 0.484384,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.193201);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.54618,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.310814,-99) , 
8, -0.877707, 0, 0, 0.532279,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.607312,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.408102,-99) , 
0, 0.0642641, 0, 0, 0.447092,-99) , 
2, 0.915129, 1, 0, 0.497575,-99) , 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.600743,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.36743,-99) , 
7, 0.0109431, 0, 0, 0.519501,-99) , 
NN2(
0, 
0, 
-1, 0.0109716, 1, -1, 0.314083,-99) , 
2, 0.912832, 0, 0, 0.406085,-99) , 
0, 0.090497, 1, 0, 0.470275,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.121128);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.547353,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.442297,-99) , 
9, 2.19355, 1, 0, 0.512075,-99) , 
NN2(
0, 
0, 
-1, -1.93539, 0, -1, 0.441438,-99) , 
0, 0.0454085, 1, 0, 0.472013,-99) , 
NN2(
0, 
0, 
-1, 10.4812, 0, -1, 0.21618,-99) , 
2, 0.476993, 0, 0, 0.466356,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0411328);
  fForest.push_back( 
NN2(
0, 
0, 
-1, 2.09027, 1, -1, 0.479445,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0470211);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.507216,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.225148,-99) , 
8, 1.80585, 1, 0, 0.503413,-99) , 
NN2(
0, 
0, 
-1, 0.275152, 1, -1, 0.34198,-99) , 
6, 2.09027, 1, 0, 0.495044,-99) , 
NN2(
0, 
0, 
-1, 10.4812, 0, -1, 0.244936,-99) , 
2, 0.476993, 0, 0, 0.489718,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0401611);
  fForest.push_back( 
NN2(
0, 
0, 
-1, 0.476993, 0, -1, 0.47993,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0402715);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.505501,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.367512,-99) , 
6, 2.09027, 1, 0, 0.498447,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.22645,-99) , 
8, 1.80585, 1, 0, 0.494833,-99) , 
NN2(
0, 
0, 
-1, 10.4812, 0, -1, 0.261415,-99) , 
2, 0.476993, 0, 0, 0.489961,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0616138);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.584363,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.481744,-99) , 
4, 7.40221, 0, 0, 0.489405,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.233582,-99) , 
8, 1.80585, 1, 0, 0.48604,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.506902,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
1, 10.4812, 0, 0, 0.269265,-99) , 
2, 0.476993, 0, 0, 0.481556,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0684267);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.525146,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.471146,-99) , 
5, -1.1612, 0, 0, 0.502508,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.244793,-99) , 
8, 1.80585, 1, 0, 0.499169,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.514898,-99) , 
NN2(
0, 
0, 
-1, 4.36448, 1, -1, 0.0170151,-99) , 
4, 5.02628, 0, 0, 0.264856,-99) , 
2, 0.476993, 0, 0, 0.494384,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.199562);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.682502,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.487437,-99) , 
8, -0.345448, 1, 0, 0.548015,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.547914,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.284165,-99) , 
8, -0.405203, 0, 0, 0.477096,-99) , 
5, -1.23117, 0, 0, 0.511501,-99) , 
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.61058,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.345304,-99) , 
8, 0.289732, 1, 0, 0.502834,-99) , 
NN2(
0, 
0, 
-1, 0.0456633, 1, -1, 0.259167,-99) , 
2, 0.843596, 0, 0, 0.422302,-99) , 
5, 1.62581, 1, 0, 0.491912,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.121656);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.570064,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.458152,-99) , 
5, -1.23117, 0, 0, 0.512648,-99) , 
NN2(
0, 
0, 
-1, 0.738507, 1, -1, 0.438844,-99) , 
5, 1.62581, 1, 0, 0.496661,-99) , 
NN2(
0, 
0, 
-1, 10.4812, 0, -1, 0.253477,-99) , 
2, 0.476993, 0, 0, 0.491873,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0693506);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.520129,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.390877,-99) , 
6, 2.09027, 1, 0, 0.513141,-99) , 
NN2(
0, 
0, 
-1, 0.763986, 0, -1, 0.411711,-99) , 
0, 0.148468, 1, 0, 0.503889,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.509789,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0,-99) , 
1, 10.4812, 0, 0, 0.277179,-99) , 
2, 0.476993, 0, 0, 0.499527,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0535122);
  fForest.push_back( 
NN2(
NN2(
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.50847,-99) , 
NN2(
0, 
0, 
-1, 0, 1, -1, 0.420338,-99) , 
6, -1.93425, 0, 0, 0.49822,-99) , 
NN2(
0, 
0, 
-1, 2.45161, 1, -1, 0.392707,-99) , 
3, 13.86, 1, 0, 0.491405,-99) , 
NN2(
NN2(
0, 
0, 
-1, 0, 1, 1, 0.5121,-99) , 
NN2(
0, 
0, 
-1, 4.36448, 1, -1, 0.0208407,-99) , 
4, 5.02628, 0, 0, 0.271974,-99) , 
2, 0.476993, 0, 0, 0.487241,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT2::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT2::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
